# Algorithms
My description and understanding of algorithms<br>
This includes link to Wikipedia and C# code example I implement.
You can also check some aswers to hackerrank questions by clicking [here](https://github.com/mkhodary/hackerrank)

# Sorting Algorithms
## 1. Bubble Sorting
Class: <b>Sorting algorithm</b> <br>
Data structure:	<b>Array</b> <br>
Worst-case performance: <b>O(n^{2})</b> <br>
Best-case performance: <b>O(n)</b> <br>
Average performance: <b>O(n^{2})</b> <br>
Worst-case space complexity: <b>O(1) auxiliary</b> <br>
Wikipedia URL: [https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort)<br>
[C# Code example by me](https://github.com/mkhodary/algorithms/blob/master/Algorithms/Algorithms/Sorting/1_BubbleSort.cs) <br>

## 2. Insertion Sort
Class: <b>Sorting algorithm</b> <br>
Data structure:	<b>Array</b> <br>
Worst-case performance: <b>O(n^{2})</b> <br>
Best-case performance: <b>O(n)</b> <br>
Average performance: <b>O(n^{2})</b> <br>
Worst-case space complexity: <b>O(1) auxiliary</b> <br>
Wikipedia URL: [https://en.wikipedia.org/wiki/Insertion_sort](https://en.wikipedia.org/wiki/Insertion_sort)<br>
[C# Code example by me](https://github.com/mkhodary/algorithms/blob/master/Algorithms/Algorithms/Sorting/2_InsertionSort.cs) <br>

## 3. Selection Sort
Class: <b>Sorting algorithm</b> <br>
Data structure:	<b>Array</b> <br>
Worst-case performance: <b>O(n^{2})</b> <br>
Best-case performance: <b>O(n^{2})</b> <br>
Average performance: <b>O(n^{2})</b> <br>
Worst-case space complexity: <b>O(1) auxiliary</b> <br>
Wikipedia URL: [https://en.wikipedia.org/wiki/Selection_sort](https://en.wikipedia.org/wiki/Selection_sort)<br>
[C# Code example by me](https://github.com/mkhodary/algorithms/blob/master/Algorithms/Algorithms/Sorting/3_SelectionSort.cs) <br>

>**Note**<br>
Simple calculation shows that <b>insertion sort</b> will therefore usually perform about half as many comparisons as <b>selection sort</b>, although it can perform just as many or far fewer depending on the order the array was in prior to sorting. It can be seen as an advantage for some real-time applications that selection sort will perform identically regardless of the order of the array, while insertion sort's running time can vary considerably. <u>However, this is more often an advantage for insertion sort in that it runs much more efficiently if the array is already sorted or "close to sorted"</u>.

## 4. Quick Sort
Class: <b>Sorting algorithm</b> <br>
Data structure:	<b>Array</b> <br>
Worst-case performance: <b>O(n^{2})</b> <br>
Best-case performance: <b>O(n log n)</b> <br>
Average performance: <b>O(n log n)</b> <br>
Worst-case space complexity: <b>O(log n) auxiliary</b> <br>
Wikipedia URL: [https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort)<br>
[C# Code example by me](https://github.com/mkhodary/algorithms/blob/master/Algorithms/Algorithms/Sorting/4_QuickSort.cs) <br>

## 5. Merge Sort
Class: <b>Sorting algorithm</b> <br>
Data structure:	<b>Array</b> <br>
Worst-case performance: <b>O(n log n)</b> <br>
Best-case performance: <b>O(n log n)</b> <br>
Average performance: <b>O(n log n)</b> <br>
Worst-case space complexity: <b>O(n) auxiliary</b> <br>
Wikipedia URL: [https://en.wikipedia.org/wiki/Merge_sort](https://en.wikipedia.org/wiki/Merge_sort)<br>
[C# Code example by me](https://github.com/mkhodary/algorithms/blob/master/Algorithms/Algorithms/Sorting/5_MergeSort.cs) <br>
